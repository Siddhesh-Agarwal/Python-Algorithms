<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="Free Python Algorithms">
    <meta name="keywords" content="python, python algorithms">
    <meta name="author" content="Siddhesh Agarwal">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Algorithms</title>
    <link href="style.css" rel="stylesheet">
    <link href="prism.css" rel="stylesheet">
    <script src="prism.js"></script>
</head>
<body>
    <!-- Header -->
    <header>
        <span class="logo">
            <img src="Python_logo.png" height="50" width="50" alt="HTML logo">
        </span>
        <div class="content">
            Python Algorithms
        </div>
    </header>

    <!-- Sidebar -->
    <nav>
        <ul>
            <li><a href="#data-structures">Data structures</a></li>
            <li><a href="#searching-techniques">Searching techniques</a></li>
            <li><a href="#sorting-techniques">Sorting techniques</a></li>
        </ul>
    </nav>

    <!-- Content -->
    <div class="container">
        <h1 id="data-structures">Data Structures</h1>
        <ol>
            <li>Binary tree</li>
            <pre class="language-py"><code>class Node:
    def __init__(self, data):
        self.data = data
        self.left: Node | None = None
        self.right: Node | None = None
    
    def __str__(self):
        value = str(self.value) + " "
        left = str(self.left or "")
        right = str(self.right or "")
        return value + left + right
        
    def insert(self, data):
        if self.data:
            if data < self.data:
                if self.left is None:
                    self.left = Node(data)
                else:
                    self.left.insert(data)
            elif data > self.data:
                if self.right is None:
                    self.right = Node(data)
                else:
                    self.right.insert(data)
        else:
            self.data = data</code></pre>
            <li>Linked list</li>
            <pre class="language-py"><code>class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

    def __repr__(self):
        return self.data

class LinkedList:
    def __init__(self):
        self.head = None

    def __repr__(self):
        node = self.head
        nodes = []
        while node is not None:
            nodes.append(node.data)
            node = node.next
        nodes.append("None")
        return " -> ".join(nodes)</code></pre>
            <li>Queue</li>
            <pre class="language-py"><code>class Queue:
    def __init__(self):
        self.queue = []
        self.length = 0
        self.front = 0
                
    def __str__(self):
        return str(self.queue)
                
    def put(self, item):
        self.queue.append(item)
        self.length = self.length + 1
                
    def get(self):
        self.length = self.length - 1
        dequeued = self.queue[self.front]
        self.queue = self.queue[1:]
        return dequeued
                
    def reverse(self):
        reversed = Queue()
        for i in self.queue:
            reversed.put(i)
        return reversed
                
    def get_front(self):
        return self.queue[0]
                
    def __len__(self):
        return self.length</code></pre>
            <li>Stack</li>
            <pre class="language-py"><code>class StackOverflowError(BaseException):
    pass
  
class Stack:
    def __init__(self, **stack, limit = 10):
        self.limit = limit
        if len(stack) > self.limit:
            raise StackOverflowError
        else:
            self.stack = list(stack)

    def __str__(self):
        return str(self.stack)

    def __len__(self):
        """Return the size of the stack."""
        return len(self.stack)

    def __contains__(self, item):
        """Check if item is in stack"""
        return item in self.stack

    def push(self, data):
        """Push an element to the top of the stack."""
        if len(self.stack) >= self.limit:
            raise StackOverflowError
        self.stack.append(data)

    def pop(self):
        """Pop an element off of the top of the stack."""
        return self.stack.pop()

    def peek(self):
        """Peek at the top-most element of the stack."""
        return self.stack[-1]

    def show(self):
        """Show the stack."""
        return self.stack

    def is_empty(self):
        """Check if a stack is empty."""
        return bool(self.stack)

    def is_full(self):
        """Check if a stack is full."""
        return self.__len__() == self.limit</code></pre>
        </ol>
        <h1 id="searching-techniques">Searching Techniques</h1>
        <ol>
            <li>Binary search</li>
            <pre class="language-py"><code># Binary Search - time complexity: O(log(n) base 2)
def BinarySearch(arr, element):
    LOW = 0
    TOP = len(arr)-1
    while LOW <= TOP:
        MID = (TOP + LOW)//2
        if element > arr[MID]:
            LOW += 1
        elif element < arr[MID]:
            TOP -= 1
        else:
            return MID
    return -1</code></pre>
                <li>Jump search</li>
                <pre class="language-py"><code># Jump Search - time complexity: O(n^1/2)
def jump_search(arr, element):
    n = len(arr)
    step = int(math.floor(math.sqrt(n)))
    prev = 0
    while arr[min(step, n) - 1] < element:
        prev = step
        step += int(math.floor(math.sqrt(n)))
        if prev >= n:
            return -1
                
    while arr[prev] < element:
        prev = prev + 1
        if prev == min(step, n):
            return -1
    if arr[prev] == element:
        return prev
    return -1</code></pre>
                <li>Linear search</li>
                <pre class="language-py"><code># Linear Search - time complexity: O(n)
def LinearSearch(arr, element):
    for i in range(len(arr)):
    if arr[i] == element:
        return i
    return -1</code></pre>
        </ol>
        <h1 id="sorting-techniques">Sorting Techniques</h1>
        <ol>
            <li>Bead sort</li>
            <pre class="language-py"><code>def bead_sort(arr):
    if any(not isinstance(x, int) or x < 0 for x in arr):
        raise TypeError("Sequence must be list of non-negative integers")
    for _ in range(len(arr)):
        for i, (rod_upper, rod_lower) in enumerate(zip(arr, arr[1:])):
            if rod_upper > rod_lower:
                arr[i] -= rod_upper - rod_lower
                arr[i + 1] += rod_upper - rod_lower
    return arr</code></pre>
            <li>Bubble sort</li>
            <pre class="language-py"><code>def bubble_sort(arr):
    for iter_num in range(len(arr) - 1, 0, -1):
        for i in range(iter_num):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]</code></pre>
            <li>Counting sort</li>
            <pre class="language-py"><code>def counting_sort(arr):
    maxEl = max(arr)
    countArrayLength = maxEl+1
    countArray = [0] * countArrayLength

    for el in arr: 
        countArray[el] += 1

    for i in range(1, countArrayLength):
        countArray[i] += countArray[i-1]

    outputArray = [0] * len(arr)
    i = len(arr) - 1

    while i >= 0:
        currentEl = arr[i]
        countArray[currentEl] -= 1
        newPosition = countArray[currentEl]
        outputArray[newPosition] = currentEl
        i -= 1

    return outputArray</code></pre>
            <li>Insertion sort</li>
            <pre class="language-py"><code>def insertion_sort(arr):
    for i in range(1, len(arr)):                  
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j] :
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key</code></pre>
            <li>merge sort</li>
            <pre class="language-py"><code>def merge_sort(arr):
    def merge(left, right):
        def _merge():
            while left and right:
                yield (left if left[0] <= right[0] else right).pop(0)
            yield from left
            yield from right

        return list(_merge())

    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    return merge(merge_sort(arr[:mid]), merge_sort(arr[mid:]))</code></pre>
            <li>shell sort</li>
            <pre class="language-py"><code>def shell_sort(arr):
    gap = len(arr) // 2
    while gap > 0:
        for i in range(gap, len(arr)):
            temp = arr[i]
            j = i
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = temp
        gap = gap//2</code></pre>
            <li>quick sort</li>
            <pre class="language-py"><code>def quick_sort(arr):
    if len(arr) < 2:
        return arr
    pivot = arr.pop()
    greater: list[int] = []
    lesser: list[int] = []
    for element in arr:
        (greater if element > pivot else lesser).append(element)
    return quick_sort(lesser) + [pivot] + quick_sort(greater)</code></pre>
        </ol>
    </div>
</body>
</html>
