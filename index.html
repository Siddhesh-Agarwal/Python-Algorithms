<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="Python Algorithms">
    <meta name="keywords" content="python, algorithms">
    <meta name="author" content="Siddhesh Agarwal">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Algorithms</title>
    <link href="style.css" rel="stylesheet">
    <link href="prism.css" rel="stylesheet">
    <script src="prism.js"></script>
</head>
<body>
    <!-- Header -->
    <header>
        <span class="logo">
            <img src="Python_logo.png" height="50" width="50" alt="HTML logo">
        </span>
        <div class="content">
            Python Algorithms
        </div>
    </header>

    <!-- Sidebar -->
    <div class="sidenav">
        <a href="#data-structures">Data structures</a></>
        <a href="#searching-techniques">Searching techniques</a>
        <a href="#sorting-techniques">Sorting techniques</a>
    </div>

    <!-- Content -->
    <div class="container">
        <h1 id="data-structures">Data Structures</h1>
        <ol>
            <li>Binary tree</li>
            <pre class="language-py"><code>class Node:
    def __init__(self, data):
        self.data = data
        self.left: Node | None = None
        self.right: Node | None = None

    def __str__(self):
        value = str(self.value) + " "
        left = str(self.left or "")
        right = str(self.right or "")
        return value + left + right

    def insert(self, data):
        if self.data:
            if data < self.data:
                if self.left is None:
                    self.left = Node(data)
                else:
                    self.left.insert(data)
            elif data > self.data:
                if self.right is None:
                    self.right = Node(data)
                else:
                    self.right.insert(data)
        else:
            self.data = data

    def inorder_traversal(self, root):
        res = []
        if root:
            res = self.inorderTraversal(root.left)
            res.append(root.data)
            res = res + self.inorderTraversal(root.right)
        return res</code></pre>
            <li>Linked list</li>
            <pre class="language-py"><code>class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

    def __repr__(self):
        return self.data

class LinkedList:
    def __init__(self, nodes=None):
        self.head = None
        if nodes is not None:
            node = Node(data=nodes.pop(0))
            self.head = node
            for elem in nodes:
                node.next = Node(data=elem)
                node = node.next

    def __repr__(self):
        node = self.head
        nodes = []
        while node is not None:
            nodes.append(node.data)
            node = node.next
        nodes.append("None")
        return " -> ".join(nodes)

    def __iter__(self):
        node = self.head
        while node is not None:
            yield node
            node = node.next

    def add_first(self, node):
        node.next = self.head
        self.head = node

    def add_last(self, node):
        if self.head is None:
            self.head = node
            return
        for current_node in self:
            pass
        current_node.next = node

    def remove_node(self, target_node_data):
        if self.head is None:
            raise Exception("List is empty")

        if self.head.data == target_node_data:
            self.head = self.head.next
            return

        previous_node = self.head
        for node in self:
            if node.data == target_node_data:
                previous_node.next = node.next
                return
            previous_node = node

        raise Exception(f"Node with data '{target_node_data}' not found")</code></pre>
            <li>Queue</li>
            <pre class="language-py"><code>class Queue:
    def __init__(self):
        self.queue = []
        self.length = 0
        self.front = 0

    def __str__(self):
        return str(self.queue)

    def __len__(self):
        return self.length

    def put(self, item):
        """Put an item into the queue"""
        self.queue.append(item)
        self.length = self.length + 1

    def get(self):
        """Get the front item of the queue"""
        self.length = self.length - 1
        dequeued = self.queue[self.front]
        self.queue = self.queue[1:]
        return dequeued

    def reverse(self):
        """Reverse the queue"""
        reversed = Queue()
        for i in self.queue:
            reversed.put(i)
        return reversed

    def get_front(self):
        """Returns the front of the stack"""
        return self.queue[0]</code></pre>
            <li>Stack</li>
            <pre class="language-py"><code>class StackOverflowError(BaseException):
    pass
  
class Stack:
    def __init__(self, **stack, limit = 10):
        self.limit = limit
        if len(stack) > self.limit:
            raise StackOverflowError
        else:
            self.stack = list(stack)

    def __str__(self):
        return str(self.stack)

    def __len__(self):
        return len(self.stack)

    def __contains__(self, item):
        return item in self.stack

    def push(self, data):
        """Add a new item to the end of the stack"""
        if len(self.stack) >= self.limit:
            raise StackOverflowError
        self.stack.append(data)

    def pop(self):
        """Remove the top item from the stack"""
        return self.stack.pop()

    def peek(self):
        """Peek the top item of the stack"""
        return self.stack[-1]

    def show(self):
        """Show the stack"""
        return self.stack

    def is_empty(self):
        """Check if the stack is empty"""
        return bool(self.stack)

    def is_full(self):
        """Check if the stack is full"""
        return self.__len__() == self.limit</code></pre>
        </ol>
        <h1 id="searching-techniques">Searching Techniques</h1>
        <ol>
            <li>Binary search</li>
            <pre class="language-py"><code># Binary Search - time complexity: O(log(n) base 2)
def BinarySearch(arr, element):
    LOW = 0
    TOP = len(arr)-1
    while LOW <= TOP:
        MID = (TOP + LOW)//2
        if element > arr[MID]:
            LOW += 1
        elif element < arr[MID]:
            TOP -= 1
        else:
            return MID
    return -1</code></pre>
                <li>Jump search</li>
                <pre class="language-py"><code># Jump Search - time complexity: O(n^1/2)
def jump_search(arr, element):
    n = len(arr)
    step = int(math.floor(math.sqrt(n)))
    prev = 0
    while arr[min(step, n) - 1] < element:
        prev = step
        step += int(math.floor(math.sqrt(n)))
        if prev >= n:
            return -1
                
    while arr[prev] < element:
        prev = prev + 1
        if prev == min(step, n):
            return -1
    if arr[prev] == element:
        return prev
    return -1</code></pre>
                <li>Linear search</li>
                <pre class="language-py"><code># Linear Search - time complexity: O(n)
def LinearSearch(arr, element):
    for i in range(len(arr)):
        if arr[i] == element:
            return i
    return -1</code></pre>
        </ol>
        <h1 id="sorting-techniques">Sorting Techniques</h1>
        <ol>
            <li>Bead sort</li>
            <pre class="language-py"><code>def bead_sort(arr):
    if any(not isinstance(x, int) or x < 0 for x in arr):
        raise TypeError("Sequence must be list of non-negative integers")
    for _ in range(len(arr)):
        for i, (rod_upper, rod_lower) in enumerate(zip(arr, arr[1:])):
            if rod_upper > rod_lower:
                arr[i] -= rod_upper - rod_lower
                arr[i + 1] += rod_upper - rod_lower
    return arr</code></pre>
            <li>Bubble sort</li>
            <pre class="language-py"><code>def bubble_sort(arr):
    for iter_num in range(len(arr) - 1, 0, -1):
        for i in range(iter_num):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]</code></pre>
            <li>Counting sort</li>
            <pre class="language-py"><code>def counting_sort(arr):
    maxEl = max(arr)
    countArrayLength = maxEl+1
    countArray = [0] * countArrayLength

    for el in arr: 
        countArray[el] += 1

    for i in range(1, countArrayLength):
        countArray[i] += countArray[i-1]

    outputArray = [0] * len(arr)
    i = len(arr) - 1

    while i >= 0:
        currentEl = arr[i]
        countArray[currentEl] -= 1
        newPosition = countArray[currentEl]
        outputArray[newPosition] = currentEl
        i -= 1

    return outputArray</code></pre>
            <li>Insertion sort</li>
            <pre class="language-py"><code>def insertion_sort(arr):
    for i in range(1, len(arr)):                  
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j] :
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key</code></pre>
            <li>merge sort</li>
            <pre class="language-py"><code>def merge_sort(arr):
    def merge(left, right):
        def _merge():
            while left and right:
                yield (left if left[0] <= right[0] else right).pop(0)
            yield from left
            yield from right

        return list(_merge())

    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    return merge(merge_sort(arr[:mid]), merge_sort(arr[mid:]))</code></pre>
            <li>shell sort</li>
            <pre class="language-py"><code>def shell_sort(arr):
    gap = len(arr) // 2
    while gap > 0:
        for i in range(gap, len(arr)):
            temp = arr[i]
            j = i
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = temp
        gap = gap//2</code></pre>
            <li>quick sort</li>
            <pre class="language-py"><code>def quick_sort(arr):
    if len(arr) < 2:
        return arr
    pivot = arr.pop()
    greater: list[int] = []
    lesser: list[int] = []
    for element in arr:
        (greater if element > pivot else lesser).append(element)
    return quick_sort(lesser) + [pivot] + quick_sort(greater)</code></pre>
        </ol>
    </div>
</body>
</html>
