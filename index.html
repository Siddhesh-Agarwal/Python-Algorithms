<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="Python Algorithms">
    <meta name="keywords" content="python, algorithms">
    <meta name="author" content="Siddhesh Agarwal">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1e2327">
    <meta name="color-scheme" content="dark light">
    <title>Python Algorithms</title>
    <link href="/manifest.json" rel="manifest" crossorigin="use-credentials">
    <link href="style.css" rel="stylesheet">
    <link href="prism.css" rel="stylesheet">
    <script src="prism.js"></script>
</head>
<body>
    <!-- Header -->
    <header>
        <span class="logo">
            <img src="img/Python-512x512.png" alt="Python logo" height="50" width="50">
        </span>
        <div class="content">
            <a href="">Python Algorithms</a>
        </div>
    </header>

    <!-- Sidebar -->
    <div class="sidenav">
        <a href="basics.html" class="disabled">Python Basics</a>
        <a href="#base-conversions">Base Conversions</a>
        <a href="#data-structures">Data Structures</a>
        <a href="#math">Math</a>
        <a href="#primes">Primes</a>
        <a href="#regex">Regex</a>
        <a href="#searching-techniques">Searching Techniques</a>
        <a href="#sorting-techniques">Sorting Techniques</a>
    </div>

    <!-- Content -->
    <div class="container">
        <!-- Base Conversions-->
        <h1 id="base-conversions">Base Conversions</h1>
        <ol>
            <li>Decimal to Binary</li>
            <pre class="line-numbers"><code class="language-py"># convert decimal numbers to binary numbers
def decimal_to_binary(decimal_number):
    binary_number = ''
    while decimal_number > 0:
        binary_number = str(decimal_number % 2) + binary_number
        decimal_number = decimal_number // 2
    return binary_number</code></pre>
            <li>Decimal to Octal</li>
            <pre class="line-numbers"><code class="language-py"># convert decimal numbers to octal numbers
def decimal_to_octal(decimal_number):
    octal_number = ''
    while decimal_number > 0:
        octal_number = str(decimal_number % 8) + octal_number
        octal_number = decimal_number // 8
    return octal_number</code></pre>
            <li>Decimal to Hexadecimal</li>
            <pre class="line-numbers"><code class="language-py"># convert decimal numbers to hexadecimal numbers
def decimal_to_hexadecimal(decimal_number):
    hexadecimal_number = ''
    hexadecimal_number_list = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']
    while decimal_number > 0:
        hexadecimal_number = hexadecimal_number_list[decimal_number % 16] + hexadecimal_number
        decimal_number = decimal_number // 16
    return hexadecimal_number</code></pre>
            <li>Binary to Decimal</li>
            <pre class="line-numbers"><code class="language-py"># convert binary numbers to decimal numbers
def binary_to_decimal(binary_number):
    decimal_number = 0
    power = 0
    for i in range(len(binary_number) - 1, -1, -1):
        decimal_number += int(binary_number[i]) * (2 ** power)
        power += 1
    return decimal_number</code></pre>
            <li>Octal to Decimal</li>
            <pre class="line-numbers"><code class="language-py"># convert octal numbers to decimal numbers
def octal_to_decimal(octal_number):
    decimal_number = 0
    power = 0
    for i in range(len(octal_number) - 1, -1, -1):
        decimal_number += int(octal_number[i]) * (8 ** power)
        power += 1
    return decimal_number</code></pre>
            <li>Hexadecimal to Decimal</li>
            <pre class="line-numbers"><code class="language-py"># convert hexadecimal numbers to decimal numbers
def hexadecimal_to_decimal(hexadecimal_number):
    decimal_number = 0
    hexadecimal_number_list = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']
    power = 0
    for i in range(len(hexadecimal_number) - 1, -1, -1):
        decimal_number += hexadecimal_number_list.index(hexadecimal_number[i]) * (16 ** power)
        power += 1
    return decimal_number</code></pre>
            <li>Binary to Octal</li>
            <pre class="line-numbers"><code class="language-py"># convert binary numbers to octal numbers
def binary_to_octal(binary_number):
    return decimal_to_octal(binary_to_decimal(binary_number))</code></pre>
            <li>Binary to Hexadecimal</li>
            <pre class="line-numbers"><code class="language-py"># convert binary numbers to hexadecimal numbers
def binary_to_hexadecimal(binary_number):
    return decimal_to_hexadecimal(binary_to_decimal(binary_number))</code></pre>
            <li>Octal to Binary</li>
            <pre class="line-numbers"><code class="language-py"># convert octal numbers to binary numbers
def octal_to_binary(octal_number):
    return decimal_to_binary(octal_to_decimal(octal_number))</code></pre>
            <li>Octal to Hexadecimal</li>
            <pre class="line-numbers"><code class="language-py"># convert octal numbers to hexadecimal numbers
def octal_to_hexadecimal(octal_number):
    return decimal_to_hexadecimal(octal_to_decimal(octal_number))</code></pre>
            <li>Hexadecimal to Binary</li>
            <pre class="line-numbers"><code class="language-py"># convert hexadecimal numbers to binary numbers
def hexadecimal_to_binary(hexadecimal_number):
    return decimal_to_binary(hexadecimal_to_decimal(hexadecimal_number))</code></pre>
            <li>Hexadecimal to Octal</li>
            <pre class="line-numbers"><code class="language-py"># convert hexadecimal numbers to octal numbers
def hexadecimal_to_octal(hexadecimal_number):
    return decimal_to_octal(hexadecimal_to_decimal(hexadecimal_number))</code></pre>
        </ol>
        <hr>
        
        <!-- Data Structures -->
        <h1 id="data-structures">Data Structures</h1>
        <ol>
            <li>Binary tree</li>
            <pre class="line-numbers"><code class="language-py">class Node:
    def __init__(self, data):
        self.data = data
        self.left: Node | None = None
        self.right: Node | None = None

    def __str__(self):
        value = str(self.value) + " "
        left = str(self.left or "")
        right = str(self.right or "")
        return value + left + right

    def insert(self, data):
        if self.data:
            if data < self.data:
                if self.left is None:
                    self.left = Node(data)
                else:
                    self.left.insert(data)
            elif data > self.data:
                if self.right is None:
                    self.right = Node(data)
                else:
                    self.right.insert(data)
        else:
            self.data = data

    def inorder_traversal(self, root):
        res = []
        if root:
            res = self.inorderTraversal(root.left)
            res.append(root.data)
            res = res + self.inorderTraversal(root.right)
        return res</code></pre>
            <li>Linked list</li>
            <pre class="line-numbers"><code class="language-py">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

    def __repr__(self):
        return self.data

class LinkedList:
    def __init__(self, nodes=None):
        self.head = None
        if nodes is not None:
            node = Node(data=nodes.pop(0))
            self.head = node
            for elem in nodes:
                node.next = Node(data=elem)
                node = node.next

    def __repr__(self):
        node = self.head
        nodes = []
        while node is not None:
            nodes.append(node.data)
            node = node.next
        nodes.append("None")
        return " -> ".join(nodes)

    def __iter__(self):
        node = self.head
        while node is not None:
            yield node
            node = node.next

    def add_first(self, node):
        node.next = self.head
        self.head = node

    def add_last(self, node):
        if self.head is None:
            self.head = node
            return
        for current_node in self:
            pass
        current_node.next = node

    def remove_node(self, target_node_data):
        if self.head is None:
            raise Exception("List is empty")

        if self.head.data == target_node_data:
            self.head = self.head.next
            return

        previous_node = self.head
        for node in self:
            if node.data == target_node_data:
                previous_node.next = node.next
                return
            previous_node = node

        raise Exception(f"Node with data '{target_node_data}' not found")</code></pre>
            <li>Queue</li>
            <pre class="line-numbers"><code class="language-py">class Queue:
    def __init__(self):
        self.queue = []
        self.length = 0
        self.front = 0

    def __str__(self):
        return str(self.queue)

    def __len__(self):
        return self.length

    def put(self, item):
        """Put an item into the queue"""
        self.queue.append(item)
        self.length = self.length + 1

    def get(self):
        """Get the front item of the queue"""
        self.length = self.length - 1
        dequeued = self.queue[self.front]
        self.queue = self.queue[1:]
        return dequeued

    def reverse(self):
        """Reverse the queue"""
        reversed = Queue()
        for i in self.queue:
            reversed.put(i)
        return reversed

    def get_front(self):
        """Returns the front of the stack"""
        return self.queue[0]</code></pre>
            <li>Stack</li>
            <pre class="line-numbers"><code class="language-py">class StackOverflowError(BaseException):
    pass
  
class Stack:
    def __init__(self, **stack, limit = 10):
        self.limit = limit
        if len(stack) > self.limit:
            raise StackOverflowError
        else:
            self.stack = list(stack)

    def __str__(self):
        return str(self.stack)

    def __len__(self):
        return len(self.stack)

    def __contains__(self, item):
        return item in self.stack

    def push(self, data):
        """Add a new item to the end of the stack"""
        if len(self.stack) >= self.limit:
            raise StackOverflowError
        self.stack.append(data)

    def pop(self):
        """Remove the top item from the stack"""
        return self.stack.pop()

    def peek(self):
        """Peek the top item of the stack"""
        return self.stack[-1]

    def show(self):
        """Show the stack"""
        return self.stack

    def is_empty(self):
        """Check if the stack is empty"""
        return bool(self.stack)

    def is_full(self):
        """Check if the stack is full"""
        return self.__len__() == self.limit</code></pre>
        </ol>
        <hr>

        <!-- Math -->
        <h1 id="math">Math</h1>
        <ol>
            <li>Euclid's Division Lemma</li>
            <pre class="line-numbers"><code class="language-py">def euclid_division_lemma(a, b):
    if b > a:
        a, b = b, a
    r = a % b
    if r == 0:
        return b
    else:
        return euclid_division_lemma(b, r)</code></pre>
            <li>Factorial</li>
            <pre class="line-numbers"><code class="language-py">def factorial(n):
    fact = 1
    for i in range(2, n + 1):
        fact = fact * i
    return fact</code></pre>
            <li>Fibonacci</li>
            <pre class="line-numbers"><code class="language-py">def fibonacci(n):
    """returns n terms from the series of Fibonacci numbers"""
    a, b = 0, 1
    arr = []
    for i in range(n):
        arr.append(a)
        a, b = b, a + b
    return arr</code></pre>
            
            <li>GCD</li>
            <pre class="line-numbers"><code class="language-py">def gcd(a, b):
    while b:
        a, b = b, a % b
    return a</code></pre>
            <li>LCM</li>
            <pre class="line-numbers"><code class="language-py">def lcm(a, b):
    return (a * b // gcd(a, b))</code></pre>
        </ol>
        <hr>

        <!-- Primes -->
        <h1 id="primes">Primes</h1>
        <ol>
            <li>Mersene Primes</li>
            <pre class="line-numbers"><code class="language-py">def is_prime(num: int):
	i = 2
	while i ** 2 <= num:
		if 	num % i == 0:
			return False
		i += 1
	return True

def mersenne_prime(num):
    """Returns mersenne prime number less than or equal to the given number.
    mersenne primes are prime numbers of the form 2^n - 1.
    >>> mersene_prime(10)
    [3, 7]
    >>> mersene_prime(100)
    [3, 7, 31]
    """
    arr = []
    power = 1
    value = 2 ** power - 1
    while value < num:
        if is_prime(value):
            arr.append(value)
        power += 1
        value = 2 ** power - 1
    return arr</code></pre>
            <li>Palindrome Primes</li>
            <pre class="line-numbers"><code class="language-py">def is_palindrome(num):
    num = str(num)
    return num == num[::-1]

def palindrome_prime(num):
    """Returns the prime numbers less than or equal to the given number which are palindromes.
    Plaindromes are numbers/strings that are the same when read from left to right and right to left.
    >>> palindrome_prime(10)
    [2, 3, 5, 7]
    >>> palindrome_prime(20)
    [2, 3, 5, 7, 11]
    """
    prime = [True] * (num + 1)
    p = 2
    while (p ** 2 <= num):
        if prime[p]:
            for i in range(p * 2, num + 1, p):
                prime[i] = False
        p += 1

    arr = []
    for p in range(2, num + 1):
        if (prime[p] and is_palindrome(p)):
            arr.append(p)
    return arr</code></pre>
                <li>Sieve of Eratosthenes</li>
            <pre class="line-numbers"><code class="language-py">def sieve_of_eratosthenese(num):
    """Returns a list of prime numbers less than or equal to the given number."""
    sieve = [num for num in range(2, num)]
    key = 0
    while key < len(sieve):
        prime = sieve[key]
        for i in range(2 * prime, num, prime):
            if i in sieve:
                sieve.remove(i)
    return sieve</code></pre>
            <li>Sophie Germain Primes</li>
            <pre class="line-numbers"><code class="language-py">def sophie_germain_prime(num):
    """Returns all Sophie Germain Prime numbers less than or equal to the given number.
    A prime number p is called Sophie Germain Prime number if (2*p + 1) is also prime.
    >>> sophie_germain_prime(25)
    [2, 3, 5, 11, 23]
    >>> sophie_germain_prime(50)
    [2, 3, 5, 11, 23, 29, 41]
    """
    prime = sieve_of_eratosthenese(2 * num + 1)
    arr = []
    for i in range(2, n + 1) :
        if i in prime and (2 * i + 1) in prime:
            arr.append(i)
    return arr</code></pre>
        </ol>
        <hr>

        <!-- Regex -->
        <h1 id="regex">Regex</h1>
        <ol>
            <li>Address Validation</li>
            <pre class="line-numbers"><code class="language-py">import regex as re

# regex for address validation
def address_validation(address):
    regex = r'^[a-zA-Z0-9\s,.-]{2,}$'
    return re.search(regex, address)</code></pre>
            <li>Credit Card Validation</li>
            <pre class="line-numbers"><code class="language-py">import regex as re

# regex for credit card validation - American Express
def credit_card_validation_american_express(credit_card):
    regex = r'^3[47][0-9]{13}$'
    return re.search(regex, credit_card)

# regex for credit card validation - BCGlobal
def credit_card_validation_BCGlobal(credit_card):
    regex = r'^(6541|6556)[0-9]{12}$'
    return re.search(regex, credit_card)

# regex for credit card validation - Carte Blanche
def credit_card_validation_carte_blanche(credit_card):
    regex = r'^389[0-9]{11}$'
    return re.search(regex, credit_card)

# regex for credit card validation - Dankort
def credit_card_validation_dankort(credit_card):
    regex = r'^(5019|4175|4571|4)\d{12}|^(5019|4175|4571|4)\d{14}|^(5019|4175|4571|4)\d{16}|^(5019|4175|4571|4)\d{18}$'
    return re.search(regex, credit_card)

# regex for credit card validation - Diners Club
def credit_card_validation_diners_club(credit_card):
    regex = r'^3(?:0[0-5]|[68][0-9])[0-9]{11}$'
    return re.search(regex, credit_card)

# regex for credit card validation - Discover
def credit_card_validation_discover(credit_card):
    regex = r'^65[4-9][0-9]{13}|64[4-9][0-9]{13}|6011[0-9]{12}|(622(?:12[6-9]|1[3-9][0-9]|[2-8][0-9][0-9]|9[01][0-9]|92[0-5])[0-9]{10})$'
    return re.search(regex, credit_card)

# regex for credit card validation - Insta Payment
def credit_card_validation_insta_payment(credit_card):
    regex = r'^63[7-9][0-9]{13}$'
    return re.search(regex, credit_card)

# regex for credit card validation - JCB
def credit_card_validation_JCB(credit_card):
    regex = r'^(?:2131|1800|35\d{3})\d{11}$'
    return re.search(regex, credit_card)

# regex for credit card validation - Korean Local
def credit_card_validation_korean_local(credit_card):
    regex = r'^9[0-9]{15}$'
    return re.search(regex, credit_card)

# regex for credit card validation - Laser
def credit_card_validation_laser(credit_card):
    regex = r'^(6304|6706|6709|6771)[0-9]{12,15}$'
    return re.search(regex, credit_card)

# regex for credit card validation - Maestro
def credit_card_validation_maestro(credit_card):
    regex = r'^(5018|5020|5038|6304|6759|6761|6763)[0-9]{8,15}$'
    return re.search(regex, credit_card)

# regex for credit card validation - Mastercard
def credit_card_validation_mastercard(credit_card):
    regex = r'^5[1-5][0-9]{14}$'
    return re.search(regex, credit_card)

# regex for credit card validation - Solo
def credit_card_validation_solo(credit_card):
    regex = r'^(6334|6767)[0-9]{12}|(6334|6767)[0-9]{14}|(6334|6767)[0-9]{15}$'
    return re.search(regex, credit_card)

# regex for credit card validation - Switch
def credit_card_validation_switch(credit_card):
    regex = r'^(4903|4905|4911|4936|6333|6759)[0-9]{12}|(4903|4905|4911|4936|6333|6759)[0-9]{14}|(4903|4905|4911|4936|6333|6759)[0-9]{15}|564182[0-9]{10}|564182[0-9]{12}|564182[0-9]{13}|633110[0-9]{10}|633110[0-9]{12}|633110[0-9]{13}$'
    return re.search(regex, credit_card)

# regex for credit card validation - UnionPay
def credit_card_validation_unionPay(credit_card):
    regex = r'^(62[0-9]{14,17})$'
    return re.search(regex, credit_card)

# regex for credit card validation - Visa
def credit_card_validation_visa(credit_card):
    regex = r'^(?:4[0-9]{12}(?:[0-9]{3})?'
    return re.search(regex, credit_card)

# regex for credit card validation - Visa Mastercard
def credit_card_validation_visa_mastercard(credit_card):
    regex = r'^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14})$'
    return re.search(regex, credit_card)

# regex for credit card validation - Visa, Mastercard, American Express, Diners Club, Discover, JCB, UnionPay, Maestro, Dankort, Carte Bleue, Switch, Solo, Visa Electron
def credit_card_validation(credit_card):
    if credit_card_validation_american_express(credit_card):
        return 'American Express'
    elif credit_card_validation_BCGlobal(credit_card):
        return 'BCGlobal'
    elif credit_card_validation_carte_blanche(credit_card):
        return 'Carte Blanche'
    elif credit_card_validation_dankort(credit_card):
        return 'Dankort'
    elif credit_card_validation_diners_club(credit_card):
        return 'Diners Club'
    elif credit_card_validation_discover(credit_card):
        return 'Discover'
    elif credit_card_validation_insta_payment(credit_card):
        return 'Insta Payment'
    elif credit_card_validation_JCB(credit_card):
        return 'JCB'
    elif credit_card_validation_korean_local(credit_card):
        return 'Korean Local'
    elif credit_card_validation_laser(credit_card):
        return 'Laser'
    elif credit_card_validation_maestro(credit_card):
        return 'Maestro'
    elif credit_card_validation_mastercard(credit_card):
        return 'Mastercard'
    elif credit_card_validation_solo(credit_card):
        return 'Solo'
    elif credit_card_validation_switch(credit_card):
        return 'Switch'
    elif credit_card_validation_unionPay(credit_card):
        return 'UnionPay'
    elif credit_card_validation_visa(credit_card):
        return 'Visa'
    elif credit_card_validation_visa_mastercard(credit_card):
        return 'Visa Mastercard'
    else:
        return 'Unknown'</code></pre>
            <li>Date Validation</li>
            <pre class="line-numbers"><code class="language-py">import regex as re

# regex for date validation (DD/MM/YYYY)
def date_validation(date):
    regex = r'^(1[0-2]|0[1-9])/(3[01]|[12][0-9]|0[1-9])/[0-9]{4}$'
    return re.search(regex, date)</code></pre>
            <li>Email Validation</li>
            <pre class="line-numbers"><code class="language-py">import regex as re

# regex for email validation
def email_validation(email):
    regex = r'(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)'
    return re.search(regex, email)</code></pre>
            <li>Name Validation</li>
            <pre class="line-numbers"><code class="language-py">import regex as re

# regex for name validation
def name_validation(name):
    regex = r'^[a-zA-Z]{2,}$'
    return re.search(regex, name)</code></pre>
            <li>Password Validation</li>
            <pre class="line-numbers"><code class="language-py">import regex as re

# regex for password validation
def password_validation(password):
    regex = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$'
    return re.search(regex, password)</code></pre>
            <li>Phone Number Validation</li>
            <pre class="line-numbers"><code class="language-py">import regex as re

# regex for phone number validation
def phone_validation(phone):
    regex = r'^[0-9]{10}$'
    return re.search(regex, phone)</code></pre>
            <li>Time Validation</li>
            <pre class="line-numbers"><code class="language-py">import regex as re

# regex for time validation HH:MM:SS
def time_validation(time):
    regex = r'^([0-1]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$'
    return re.search(regex, time)</code></pre>
            <li>URL Validation</li>
            <pre class="line-numbers"><code class="language-py">import regex as re

# regex for url validation
def URL_validation(url):
    regex = r'^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w\.-]+)+[\w\-\._~:/?#[\]@!\$&\'\(\)\*\+,;=.]+$'
    return re.search(regex, url)</code></pre>
            <li>IP Address Validation</li>
            <pre class="line-numbers"><code class="language-py">import regex as re

# regex for IP address validation IPv4
def IP_validation(IP):
    regex = r'(\b25[0-5]|\b2[0-4][0-9]|\b[01]?[0-9][0-9]?)(\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}'
    return re.search(regex, IP)</code></pre>
        </ol>
        <hr>

        <!-- Searching -->
        <h1 id="searching-techniques">Searching Techniques</h1>
        <ol>
            <li>Binary search</li>
            <pre class="line-numbers"><code class="language-py"># Binary Search - time complexity: O(log(n) base 2)
def BinarySearch(arr, element):
    LOW = 0
    TOP = len(arr)-1
    while LOW <= TOP:
        MID = (TOP + LOW)//2
        if element > arr[MID]:
            LOW += 1
        elif element < arr[MID]:
            TOP -= 1
        else:
            return MID
    return -1</code></pre>
                <li>Jump search</li>
                <pre class="line-numbers"><code class="language-py"># Jump Search - time complexity: O(n^1/2)
def jump_search(arr, element):
    n = len(arr)
    step = int(math.floor(math.sqrt(n)))
    prev = 0
    while arr[min(step, n) - 1] < element:
        prev = step
        step += int(math.floor(math.sqrt(n)))
        if prev >= n:
            return -1
                
    while arr[prev] < element:
        prev = prev + 1
        if prev == min(step, n):
            return -1
    if arr[prev] == element:
        return prev
    return -1</code></pre>
                <li>Linear search</li>
                <pre class="line-numbers"><code class="language-py"># Linear Search - time complexity: O(n)
def LinearSearch(arr, element):
    for i in range(len(arr)):
        if arr[i] == element:
            return i
    return -1</code></pre>
        </ol>
        <hr>

        <!-- Sorting -->
        <h1 id="sorting-techniques">Sorting Techniques</h1>
        <ol>
            <li>Bead sort</li>
            <pre class="line-numbers"><code class="language-py">def bead_sort(arr):
    if any(not isinstance(x, int) or x < 0 for x in arr):
        raise TypeError("Sequence must be list of non-negative integers")
    for _ in range(len(arr)):
        for i, (rod_upper, rod_lower) in enumerate(zip(arr, arr[1:])):
            if rod_upper > rod_lower:
                arr[i] -= rod_upper - rod_lower
                arr[i + 1] += rod_upper - rod_lower
    return arr</code></pre>
            <li>Bubble sort</li>
            <pre class="line-numbers"><code class="language-py">def bubble_sort(arr):
    for iter_num in range(len(arr) - 1, 0, -1):
        for i in range(iter_num):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]</code></pre>
            <li>Counting sort</li>
            <pre class="line-numbers"><code class="language-py">def counting_sort(arr):
    maxEl = max(arr)
    countArrayLength = maxEl+1
    countArray = [0] * countArrayLength

    for el in arr: 
        countArray[el] += 1

    for i in range(1, countArrayLength):
        countArray[i] += countArray[i-1]

    outputArray = [0] * len(arr)
    i = len(arr) - 1

    while i >= 0:
        currentEl = arr[i]
        countArray[currentEl] -= 1
        newPosition = countArray[currentEl]
        outputArray[newPosition] = currentEl
        i -= 1

    return outputArray</code></pre>
            <li>Insertion sort</li>
            <pre class="line-numbers"><code class="language-py">def insertion_sort(arr):
    for i in range(1, len(arr)):                  
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j] :
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key</code></pre>
            <li>merge sort</li>
            <pre class="line-numbers"><code class="language-py">def merge_sort(arr):
    def merge(left, right):
        def _merge():
            while left and right:
                yield (left if left[0] <= right[0] else right).pop(0)
            yield from left
            yield from right

        return list(_merge())

    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    return merge(merge_sort(arr[:mid]), merge_sort(arr[mid:]))</code></pre>
            <li>shell sort</li>
            <pre class="line-numbers"><code class="language-py">def shell_sort(arr):
    gap = len(arr) // 2
    while gap > 0:
        for i in range(gap, len(arr)):
            temp = arr[i]
            j = i
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = temp
        gap = gap//2</code></pre>
            <li>quick sort</li>
            <pre class="line-numbers"><code class="language-py">def quick_sort(arr):
    if len(arr) < 2:
        return arr
    pivot = arr.pop()
    greater: list[int] = []
    lesser: list[int] = []
    for element in arr:
        (greater if element > pivot else lesser).append(element)
    return quick_sort(lesser) + [pivot] + quick_sort(greater)</code></pre>
        </ol>
    </div>

    <div class="arrow">
        <button><a href="">Up</a></button>
    </div>
</body>
</html>
