<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="Python Algorithms">
    <meta name="keywords" content="python, algorithms">
    <meta name="author" content="Siddhesh Agarwal">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Algorithms</title>
    <link href="style.css" rel="stylesheet">
    <link href="prism.css" rel="stylesheet">
    <script src="prism.js"></script>
</head>
<body>
    <!-- Header -->
    <header>
        <span class="logo">
            <img src="Python_logo.png" height="50" width="50" alt="HTML logo">
        </span>
        <div class="content">
            Python Algorithms
        </div>
    </header>

    <!-- Sidebar -->
    <div class="sidenav">
        <a href="#data-structures">Data Structures</a>
        <a href="#math">Math</a>
        <a href="#primes">Primes</a>
        <a href="#regex">Regex</a>
        <a href="#searching-techniques">Searching Techniques</a>
        <a href="#sorting-techniques">Sorting Techniques</a>
    </div>

    <!-- Content -->
    <div class="container">
        <h1 id="data-structures">Data Structures</h1>
        <ol>
            <li>Binary tree</li>
            <pre class="language-py"><code>class Node:
    def __init__(self, data):
        self.data = data
        self.left: Node | None = None
        self.right: Node | None = None

    def __str__(self):
        value = str(self.value) + " "
        left = str(self.left or "")
        right = str(self.right or "")
        return value + left + right

    def insert(self, data):
        if self.data:
            if data < self.data:
                if self.left is None:
                    self.left = Node(data)
                else:
                    self.left.insert(data)
            elif data > self.data:
                if self.right is None:
                    self.right = Node(data)
                else:
                    self.right.insert(data)
        else:
            self.data = data

    def inorder_traversal(self, root):
        res = []
        if root:
            res = self.inorderTraversal(root.left)
            res.append(root.data)
            res = res + self.inorderTraversal(root.right)
        return res</code></pre>
            <li>Linked list</li>
            <pre class="language-py"><code>class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

    def __repr__(self):
        return self.data

class LinkedList:
    def __init__(self, nodes=None):
        self.head = None
        if nodes is not None:
            node = Node(data=nodes.pop(0))
            self.head = node
            for elem in nodes:
                node.next = Node(data=elem)
                node = node.next

    def __repr__(self):
        node = self.head
        nodes = []
        while node is not None:
            nodes.append(node.data)
            node = node.next
        nodes.append("None")
        return " -> ".join(nodes)

    def __iter__(self):
        node = self.head
        while node is not None:
            yield node
            node = node.next

    def add_first(self, node):
        node.next = self.head
        self.head = node

    def add_last(self, node):
        if self.head is None:
            self.head = node
            return
        for current_node in self:
            pass
        current_node.next = node

    def remove_node(self, target_node_data):
        if self.head is None:
            raise Exception("List is empty")

        if self.head.data == target_node_data:
            self.head = self.head.next
            return

        previous_node = self.head
        for node in self:
            if node.data == target_node_data:
                previous_node.next = node.next
                return
            previous_node = node

        raise Exception(f"Node with data '{target_node_data}' not found")</code></pre>
            <li>Queue</li>
            <pre class="language-py"><code>class Queue:
    def __init__(self):
        self.queue = []
        self.length = 0
        self.front = 0

    def __str__(self):
        return str(self.queue)

    def __len__(self):
        return self.length

    def put(self, item):
        """Put an item into the queue"""
        self.queue.append(item)
        self.length = self.length + 1

    def get(self):
        """Get the front item of the queue"""
        self.length = self.length - 1
        dequeued = self.queue[self.front]
        self.queue = self.queue[1:]
        return dequeued

    def reverse(self):
        """Reverse the queue"""
        reversed = Queue()
        for i in self.queue:
            reversed.put(i)
        return reversed

    def get_front(self):
        """Returns the front of the stack"""
        return self.queue[0]</code></pre>
            <li>Stack</li>
            <pre class="language-py"><code>class StackOverflowError(BaseException):
    pass
  
class Stack:
    def __init__(self, **stack, limit = 10):
        self.limit = limit
        if len(stack) > self.limit:
            raise StackOverflowError
        else:
            self.stack = list(stack)

    def __str__(self):
        return str(self.stack)

    def __len__(self):
        return len(self.stack)

    def __contains__(self, item):
        return item in self.stack

    def push(self, data):
        """Add a new item to the end of the stack"""
        if len(self.stack) >= self.limit:
            raise StackOverflowError
        self.stack.append(data)

    def pop(self):
        """Remove the top item from the stack"""
        return self.stack.pop()

    def peek(self):
        """Peek the top item of the stack"""
        return self.stack[-1]

    def show(self):
        """Show the stack"""
        return self.stack

    def is_empty(self):
        """Check if the stack is empty"""
        return bool(self.stack)

    def is_full(self):
        """Check if the stack is full"""
        return self.__len__() == self.limit</code></pre>
        </ol>
        <hr>
        <h1 id="math">Math</h1>
        <ol>
            <li>Euclid's Division Lemma</li>
            <pre class="language-py"><code>def euclid_division_lemma(a, b):
    r = a % b
    if r == 0:
        return b
    else:
        return euclid_division_lemma(b, r)</code></pre>
            <li>Factorial</li>
            <pre class="language-py"><code>def factorial(n):
    fact = 1
    for i in range(2, n + 1):
        fact = fact * i
    return fact</code></pre>
            <li>Fibonacci</li>
            <pre class="language-py"><code>def fibonacci(n):
    a, b = 0, 1
    for i in range(n):
        a, b = b, a + b
    return a</code></pre>
            
            <li>GCD</li>
            <pre class="language-py"><code>def gcd(a, b):
    while b:
        a, b = b, a % b
    return a</code></pre>
            <li>LCM</li>
            <pre class="language-py"><code>def lcm(a, b):
    return (a * b // gcd(a, b))</code></pre>
        </ol>
        <hr>
        <h1 id="primes">Primes</h1>
        <ol>
            <li>Mersene Primes</li>
            <pre class="language-py"><code>def is_prime(num):
    for i in range(2, num // 2):
        if num % i == 0:
            return False
    return True

def mersenne_prime(num):
    """Returns mersenne prime number less than or equal to the given number.
    mersenne primes are prime numbers of the form 2^n - 1.
    >>> mersene_prime(10)
    [3, 7]
    >>> mersene_prime(100)
    [3, 7, 31]
    """
    arr = []
    power = 1
    value = 2 ** power - 1
    while value < num:
        if is_prime(value):
            arr.append(value)
        power += 1
        value = 2 ** power - 1
    return arr</code></pre>
            <li>Palindrome Primes</li>
            <pre class="language-py"><code>def is_palindrome(num):
    num = str(num)
    return num == num[::-1]

def palindrome_prime(num):
    """Returns the prime numbers less than or equal to the given number which are palindromes.
    Plaindromes are numbers/strings that are the same when read from left to right and right to left.
    >>> palindrome_prime(10)
    [2, 3, 5, 7]
    >>> palindrome_prime(20)
    [2, 3, 5, 7, 11]
    """
    prime = [True] * (num + 1)
    p = 2
    while (p ** 2 <= num):
        if prime[p]:
            for i in range(p * 2, num + 1, p):
                prime[i] = False
        p += 1

    arr = []
    for p in range(2, num + 1):
        if (prime[p] and is_palindrome(p)):
            arr.append(p)
    return arr</code></pre>
                <li>Sieve of Eratosthenes</li>
            <pre class="language-py"><code>def sieve_of_eratosthenese(num):
    """Returns a list of prime numbers less than or equal to the given number."""
    sieve = [num for num in range(2, num)]
    key = 0
    while key < len(sieve):
        prime = sieve[key]
        for i in range(2 * prime, num, prime):
            if i in sieve:
                sieve.remove(i)
    return sieve</code></pre>
            <li>Sophie Germain Primes</li>
            <pre class="language-py"><code>def sophie_germain_prime(num):
    """Returns all Sophie Germain Prime numbers less than or equal to the given number.
    A prime number p is called Sophie Germain Prime number if (2*p + 1) is also prime.
    >>> sophie_germain_prime(25)
    [2, 3, 5, 11, 23]
    >>> sophie_germain_prime(50)
    [2, 3, 5, 11, 23, 29, 41]
    """
    prime = sieve_of_eratosthenese(2 * num + 1)
    arr = []
    for i in range(2, n + 1) :
        if i in prime and (2 * i + 1) in prime:
            arr.append(i)
    return arr</code></pre>
        </ol>
        <hr>
        <h1 id="regex">Regex</h1>
        <ol>
            <li>Address Validation</li>
            <pre class="language-py"><code>import regex as re

# regex for address validation
def address_validation(address):
    regex = r'^[a-zA-Z0-9\s,.-]{2,}$'
    return re.search(regex, address)</code></pre>
            <li>Date Validation</li>
            <pre class="language-py"><code>import regex as re

# regex for date validation (DD/MM/YYYY)
def date_validation(date):
    regex = r'^(1[0-2]|0[1-9])/(3[01]|[12][0-9]|0[1-9])/[0-9]{4}$'
    return re.search(regex, date)</code></pre>
            <li>Email Validation</li>
            <pre class="language-py"><code>import regex as re

# regex for email validation
def email_validation(email):
    regex = r'(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)'
    return re.search(regex, email)</code></pre>
            <li>Name Validation</li>
            <pre class="language-py"><code>import regex as re

# regex for name validation
def name_validation(name):
    regex = r'^[a-zA-Z]{2,}$'
    return re.search(regex, name)</code></pre>
            <li>Password Validation</li>
            <pre class="language-py"><code>import regex as re

# regex for password validation
def password_validation(password):
    regex = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$'
    return re.search(regex, password)</code></pre>
            <li>Phone Number Validation</li>
            <pre class="language-py"><code>import regex as re

# regex for phone number validation
def phone_validation(phone):
    regex = r'^[0-9]{10}$'
    return re.search(regex, phone)</code></pre>
            <li>URL Validation</li>
            <pre class="language-py"><code>import regex as re

# regex for url validation
def URL_validation(url):
    regex = r'^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w\.-]+)+[\w\-\._~:/?#[\]@!\$&\'\(\)\*\+,;=.]+$'
    return re.search(regex, url)</code></pre>
            <li>IP Address Validation</li>
            <pre class="language-py"><code>import regex as re

# regex for IP address validation IPv4
def IP_validation(IP):
    regex = r'(\b25[0-5]|\b2[0-4][0-9]|\b[01]?[0-9][0-9]?)(\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}'
    return re.search(regex, IP)</code></pre>
        </ol>
        <hr>
        <h1 id="searching-techniques">Searching Techniques</h1>
        <ol>
            <li>Binary search</li>
            <pre class="language-py"><code># Binary Search - time complexity: O(log(n) base 2)
def BinarySearch(arr, element):
    LOW = 0
    TOP = len(arr)-1
    while LOW <= TOP:
        MID = (TOP + LOW)//2
        if element > arr[MID]:
            LOW += 1
        elif element < arr[MID]:
            TOP -= 1
        else:
            return MID
    return -1</code></pre>
                <li>Jump search</li>
                <pre class="language-py"><code># Jump Search - time complexity: O(n^1/2)
def jump_search(arr, element):
    n = len(arr)
    step = int(math.floor(math.sqrt(n)))
    prev = 0
    while arr[min(step, n) - 1] < element:
        prev = step
        step += int(math.floor(math.sqrt(n)))
        if prev >= n:
            return -1
                
    while arr[prev] < element:
        prev = prev + 1
        if prev == min(step, n):
            return -1
    if arr[prev] == element:
        return prev
    return -1</code></pre>
                <li>Linear search</li>
                <pre class="language-py"><code># Linear Search - time complexity: O(n)
def LinearSearch(arr, element):
    for i in range(len(arr)):
        if arr[i] == element:
            return i
    return -1</code></pre>
        </ol>
        <hr>
        <h1 id="sorting-techniques">Sorting Techniques</h1>
        <ol>
            <li>Bead sort</li>
            <pre class="language-py"><code>def bead_sort(arr):
    if any(not isinstance(x, int) or x < 0 for x in arr):
        raise TypeError("Sequence must be list of non-negative integers")
    for _ in range(len(arr)):
        for i, (rod_upper, rod_lower) in enumerate(zip(arr, arr[1:])):
            if rod_upper > rod_lower:
                arr[i] -= rod_upper - rod_lower
                arr[i + 1] += rod_upper - rod_lower
    return arr</code></pre>
            <li>Bubble sort</li>
            <pre class="language-py"><code>def bubble_sort(arr):
    for iter_num in range(len(arr) - 1, 0, -1):
        for i in range(iter_num):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]</code></pre>
            <li>Counting sort</li>
            <pre class="language-py"><code>def counting_sort(arr):
    maxEl = max(arr)
    countArrayLength = maxEl+1
    countArray = [0] * countArrayLength

    for el in arr: 
        countArray[el] += 1

    for i in range(1, countArrayLength):
        countArray[i] += countArray[i-1]

    outputArray = [0] * len(arr)
    i = len(arr) - 1

    while i >= 0:
        currentEl = arr[i]
        countArray[currentEl] -= 1
        newPosition = countArray[currentEl]
        outputArray[newPosition] = currentEl
        i -= 1

    return outputArray</code></pre>
            <li>Insertion sort</li>
            <pre class="language-py"><code>def insertion_sort(arr):
    for i in range(1, len(arr)):                  
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j] :
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key</code></pre>
            <li>merge sort</li>
            <pre class="language-py"><code>def merge_sort(arr):
    def merge(left, right):
        def _merge():
            while left and right:
                yield (left if left[0] <= right[0] else right).pop(0)
            yield from left
            yield from right

        return list(_merge())

    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    return merge(merge_sort(arr[:mid]), merge_sort(arr[mid:]))</code></pre>
            <li>shell sort</li>
            <pre class="language-py"><code>def shell_sort(arr):
    gap = len(arr) // 2
    while gap > 0:
        for i in range(gap, len(arr)):
            temp = arr[i]
            j = i
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = temp
        gap = gap//2</code></pre>
            <li>quick sort</li>
            <pre class="language-py"><code>def quick_sort(arr):
    if len(arr) < 2:
        return arr
    pivot = arr.pop()
    greater: list[int] = []
    lesser: list[int] = []
    for element in arr:
        (greater if element > pivot else lesser).append(element)
    return quick_sort(lesser) + [pivot] + quick_sort(greater)</code></pre>
        </ol>
    </div>
</body>
</html>
